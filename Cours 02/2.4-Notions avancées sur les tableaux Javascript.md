# Notions avancées sur les tableaux JavaScript

## 1. La syntaxe de décomposition (*spread syntax*)

Selon le [MDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/Spread_syntax), la **syntaxe de décomposition** permet d'étendre un itérable JavaScript (chaînes de caractères, tableaux et objets, entre autres) et de remplacer :

- une *liste d'arguments* pour les **appels de fonctions**
- une *liste d'éléments* pour les **littéraux de tableaux**
- une *liste de paires clés-valeurs* pour les **littéraux d'objets**

### Syntaxe (de décomposition)

On utilise l'expression `...` (trois points) devant la référence de l'itérable à étendre.

### Exemples : Syntaxe de décomposition

```javascript
const tab1 = [1, 2, 3];
const tab2 = [4, 5];
const obj1 = { prenom: "Max", nom: "Faucher", age: 45 };
const obj2 = { age: 46, estRetraite: false };


// EXEMPLE 1 : appel de fonction
tab1.push(...tab2); // va ajouter à la fin de tab1 les éléments de tab2
console.log(tab1); // tab1 est maintenant [ 1, 2, 3, 4, 5 ]

// EXEMPLE 2 : littéral de tableau
const tab3 = [0, ...tab2, 10]; // va "coller" les 2 tableaux
console.log(tab3); // tab3 est maintenant [ 0, 4, 5, 10 ]

// EXEMPLE 3: littéral d'objet
const obj3 = { ...obj1, ...obj2 }; // va "fusionner" les 2 objets : écrasement de valeurs possibles
console.log(obj3); // obj3 est maintenant { prenom: 'Max', nom: 'Faucher', age: 46, estRetraite: false }
```

## 2. Méthodes utiles

### Méthode [`.forEach(callbackFn)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)

- **But** : Sert à exécuter une fonction de rappel `callbackFn` pour chaque élément du tableau.
- **Retour** : Aucun (`undefined`)

```javascript
array.forEach((element, index, tableau) => {
  // instructions qui retournent une valeur
});
```

REMARQUES sur `.forEach()` :

- **La boucle** sur les éléments parcourus **ne peut pas être interrompue** avant la fin
- Cette méthode **attend une fonction de rappel synchrone**, donc elle n'attend pas les promesses
- La **fonction de rappel peut prendre 3 paramètres** : `element`, `index` et `tableau` qui réfèrent respectivement à l'élément courant, l'indice actuel et le tableau parcouru.

```javascript
const nombres = [1, 2, 3];
nombres.forEach(n => console.log(n));
// Affiche
// 1
// 2
// 3
```

## 2. Méthode [`.map(callbackFn)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

- **But** : Sert à crér un nouveau tableau rempli avec les résultats de l'appel de `callbackFn` sur chaque élément du tableau appelant.
- **Retour** : Un nouveau tableau composé des images (résultats) de la fonction de rappel.

```javascript
const resultat = array.map((element, index, tableau) => {
  // instructions qui retournent une valeur
});
```

REMARQUES sur `.map()` :

- `callbackFn` n'est appelée que pour les indices du tableau qui ont des valeurs affectées. Elle n'est pas appelée pour les cases vides.
- Puisque map construit un nouveau tableau, l'appeler sans utiliser le tableau retourné est une mauvaise pratique : utilisez plutôt `forEach` ou `for...of`.
- La **fonction de rappel peut prendre 3 paramètres** : `element`, `index` et `tableau` qui réfèrent respectivement à l'élément courant, l'indice actuel et le tableau parcouru.

```javascript
const nombres = [1, 2, 3];
const doubles = nombres.map(n => n * 2);
console.log(doubles); // [ 2, 4, 6 ]
```

## 3. Méthode [`.filter(callbackFn)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

- **But** : Sert à crée une copie (superficielle) d'une portion d'un tableau donné, filtrée pour ne contenir que les éléments du tableau d'origine qui passent le test implémenté par la fonction `callbackFn`.
- **Retour** : Une copie superficielle du tableau donné contenant uniquement les éléments qui passent le test. Si aucun élément ne passe le test, `[]` est renvoyé.

```javascript
const resultat = array.filter((element, index, tableau) => condition); // condition retourne true ou false
const resultat = array.filter((element, index, tableau) => {
  // instructions qui retournent true ou false
});
```

REMARQUES sur `.filter()`

- `callbackFn` n'est appelée que pour les indices du tableau qui ont des valeurs affectées. Elle n'est pas appelée pour les cases vides.
- La **fonction de rappel peut prendre 3 paramètres** : `element`, `index` et `tableau` qui réfèrent respectivement à l'élément courant, l'indice actuel et le tableau parcouru.

```javascript
const nombres = [1, 2, 3, 4, 5];
const pairs = nombres.filter(n => n % 2 === 0); // condition : n % 2 === 0
console.log(pairs) // [ 2, 4 ]
```

## 4. Méthode [`.reduce(callbackFn, initialValue?)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

- **But** : exécute `callbackFn`, une fonction « de réduction » fournie par l'utilisateur sur chaque élément du tableau, dans l'ordre, en **transmettant la valeur retournée par le calcul précédent**. Le **résultat final** de l'exécution du réducteur sur tous les éléments du tableau **est une seule valeur**.
- **Retour** : La valeur qui résulte de l'exécution de `callbackFn` sur l'ensemble du tableau jusqu'à la fin.

```javascript
const resultat = array.reduce((accumulateur, element, index, tableau) => {
  // instructions qui retournent une nouvelle valeur pour accumulateur
}, valeurInitiale);
```

REMARQUES sur `.reduce()`

- `callbackFn` n'est appelée que pour les indices du tableau qui ont des valeurs affectées. Elle n'est pas appelée pour les cases vides.
- La **fonction de rappel peut prendre 4 paramètres** :
    1. `accumulateur` : 
    2. `element` : La valeur de l'élément courant. Vaut `tableau[0]` si `initialValue` est fournie, sinon vaut `tableau[1]`.
    3. `index` : L'indice de `element`. Vaut `0` si `initialValue` est fournie, sinon vaut `1`.
    4. `tableau` : Le tableau parcourum, sur lequel `.reduce()` est appelé.
- **Le second paramètre** `initialValue` représente **la valeur à laquelle `accumulateur` est initialisé lors du premier appel de `callbackFn`**. 
- La méthode commence par le premier élément si `initialValue` est fournie, sinon elle commence au second élément.
- Si `initialValue` n'est pas fournie et que le tableau est vide, une erreur est lancée.

```javascript
const nombres = [1, 2, 3, 4];
const somme = nombres.reduce((acc, elm) => acc + elm, 0); // valeur initiale fournie (0)
console.log(somme) // 10

const memeSomme = nombres.reduce((acc, elm) => acc + elm); // valeur initiale omise
console.log(autreSomme) // 10
// équivalent à [2, 3, 4].reduce((acc, elm) => acc + elm, 1);
```
