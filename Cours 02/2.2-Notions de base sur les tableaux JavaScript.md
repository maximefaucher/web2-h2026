# Notions de base sur les tableaux JavaScript (Arrays)

Les tableaux (arrays) sont des **collections ordonn√©es de valeurs** (de n'importe quel type : nombres, cha√Ænes, objets, fonctions‚Ä¶). Ils sont index√©s √† partir de `0`. Les valeurs sont plac√©es entre `[ ]` et s√©par√©es par des `,`.

REMARQUE : on utilise parfois le mot **liste** pour pourler de tableaux en JavaScript.

## 1. D√©finition et syntaxe

```javascript
// Litt√©ral de tableau (recommand√©)
const notes = [12, 14, 9, 16];

// Tableau h√©t√©rog√®ne
const mix = [42, "allo", true, { x: 1 }, [1, 2]];

// Tableau vide, puis remplissage
let fruits = [];
fruits = ["pomme", "banane"];

// Constructeur (√† √©viter pour cr√©er un tableau rempli d'√©l√©ments identiques)
const arr1 = new Array(3);      // [ <3 √©l√©ments vides> ] -> longueur 3, valeurs "vides"
const arr2 = Array.of(3);       // [3] -> utilise Array.of pour √©viter l'ambigu√Øt√©
```

‚úÖ Conseil : Pr√©f√©rez la notation litt√©rale `[ ]` et `Array.of()` lorsque n√©cessaire.

## 2. Taille : propri√©t√© `.length`

La propri√©t√© `length` donne le nombre d'√©l√©ments dans le tableau. Il est mutable : le r√©duire tronque le tableau. L'augmenter va ajouter des √©l√©ments vides (*empty items*).

```javascript
const a = ["A", "B", "C"];
console.log(a.length); // 3

a.length = 2;          // tronque
console.log(a);        // ["A", "B"]

a.length = 5;          // √©tend -> ajoute des "trous" (√©l√©ments vides)
console.log(a);        // ["A", "B", <3 empty items>]
```

## 3. Acc√©der √† un √©l√©ment (lire) / Remplacer un √©l√©ment : indices

On utilise les indices positifs, qui vont de `0` (premier) √† `length - 1` (dernier).

```javascript
const t = ["A", "B", "C", "D", "E"];
// Lire via les indices
console.log(t[0]);  // "A"
console.log(t[t.length - 1]);  // "E", √©quivaut √† t[4]
console.log(t[99]); // undefined (hors bornes), n'est pas une valeur vide

// Remplacer un √©l√©ment
t[1] = "Z";
console.log(t); // [ 'A', 'Z', 'C', 'D', 'E' ]
// On peut aussi ajouter au-del√† de la fin (cr√©era des "trous")¬†:
const t2 = ["A"];
t2[3] = "X";
console.log(t2); // ["A", <2 empty items>, "X"]
```

## 4. Parcourir un tableau

### Boucle `for` standard

‚úÖ Contr√¥le total sur l'indice.

```javascript
const tFor = [10, 20, 30];
for (let i = 0; i < tFor.length; i++) {
  console.log(i, tFor[i]); // indice, valeur
}
```

### Boucle `for of`

‚úÖ Lisible, moderne.  
‚ùå N'offre pas directement l'indice (utiliser `t.entries()` si besoin).

```javascript
const tOf = ["a", "b", "c", "d", "e"];
for (const valeur of tOf) {
  console.log(valeur);
}
// Pour acc√©der √† l'indice, utiliser .entries()
for (const [i, v] of tOf.entries()) {
  console.log(i, v);
}
```

## 5. M√©thodes utiles

### [`at(index)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/at)

- **Effet** : Immuable (n'alt√®re pas le tableau)
- **But** : acc√®s par indice **positif** ou **n√©gatif** (depuis la fin)
- **Retour** : la valeur √† l'indice donn√© ou `undefined`

```javascript
const t = ["A", "B", "C"];
t.at(0);  // "A"
t.at(-1); // "C"
t.at(3); // undefined
t.at(-3); // "A"
t.at(-4); // undefined
```

### [`push(...items)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/push)

- **Effet** : Muable (ajoute en **fin**)
- **But** : Ajouter un √©l√©ment
- **Retour** : La nouvelle longueur du tableau

```javascript
const tPush = [1, 2];
const n = tPush.push(3, 4);
console.log(tPush, n); // [ 1, 2, 3, 4 ] 4
```

### [`pop()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)

- **Effet** : Muable (retire le **dernier**)
- **But** : Retirer le dernier √©l√©ment
- **Retour** : Le dernier √©l√©ment, celui qui est retir√©. `undefined` si le tableau est vide.

```javascript
const tPop = [8, 9, 10, 11];
const r = tPop.pop();
console.log(tPop, r); // [ 8, 9, 10 ] 11
```

### [`unshift(...items)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)

- **Effet** : Muable (aujoute en **d√©but**)
- **But** : Ajouter un √©l√©ment
- **Retour** : La nouvelle longueur du tableau

```javascript
const tUnshift = [9, 12, 15];
const m = tUnshift.unshift(3, 6);
console.log(tUnshift, m); // [ 3, 6, 9, 12, 15 ] 5
```

### [`shift()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)

- **Effet** : Muable (retire le **premier**)
- **But** : Retrait du premier √©l√©ment
- **Retour** : L'√©l√©ment retir√© (ou `undefined` si vide)

```javascript
const tShift = [4, 5, 6];
const d = tShift.shift();
console.log(tShift, d); // [ 5, 6 ] 4
```

### [`indexOf(value, fromIndex = 0)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)

- **Effet** : Immuable
- **But** : Recherche par √©galit√© stricte (`===`) [pour en savoir plus](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Operators/Strict_equality)
- **Retour** : Le premier indice de `value`, ou `-1` si non trouv√©

üí° Pour objets/r√©f√©rences, `indexOf` ne fonctionne que si c'est la **m√™me r√©f√©rence**.

```javascript
const unTab = ['x', 'y', 'z'];
const tIndexOf = ["A", "B", "A"];
console.log(tIndexOf.indexOf("A"));    // 0
console.log(tIndexOf.indexOf("A", 1)); // 2
console.log(tIndexOf.indexOf("Z"));    // -1
tIndexOf.push(['x', 'y', 'z']);        // pas la m√™me r√©f√©rence que unTab
console.log(tIndexOf.indexOf(unTab));  // -1
console.log(tIndexOf.indexOf(['x', 'y', 'z']));  // -1
```

### [`sort(compareFn?)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)

- **Effet** : Muable, peut d√©placer les √©l√©ments
- **But** : Trier les √©l√©ments. Sans `compareFn`, va faire un tri alphab√©tique (ordre des caract√®re `UTF-16`)
- **Retour** : La r√©f√©rence vers le tableau d'origine, d√©sormais tri√©.

‚úÖ Astuce : utiliser une copie pour conserver l'original

```javascript
const tSort1 = [10, 2, 30];
console.log(tSort1.sort()); // ["10", "2", "30"] -> tri lexicographique -> [10, 2, 30] "mal tri√©" num√©riquement
const tSort2 = [10, 2, 30];
console.log(tSort2.sort((a, b) => a - b)); // [2, 10, 30]
const tSort3 = ["A", "a", "B"];
const tSort3Trie = [...tSort3].sort(); // 
const tSort3Trie2 = tSort3.slice().sort(); // .slice() retourne une copie superficielle
console.log(tSort3, tSort3Trie, tSort3Trie2); // [ 'A', 'a', 'B' ] [ 'A', 'B', 'a' ] [ 'A', 'B', 'a' ]
// Les majuscules sont avant les minuscule en ordre UTF-16
```

### [`reverse()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)

- **Effet** : Muable
- **But** : Renverser l'ordre **actuel** des √©l√©ments (pas ordre invers√©!)
- **Retour** : La r√©f√©rence vers le tableau d'origine, d√©sormais invers√©.

‚úÖ Immuable alternatif : `const r = [...t].reverse();`

```javascript
const tReverse1 = [3, 1, 2, 5, 4];
console.log(tReverse1.reverse()); // [ 4, 5, 2, 1, 3 ]
const tReverse2 = [8, 6, 3, 1];
const tReverse2Inverse = [...tReverse2].reverse();
console.log(tReverse2, tReverse2Inverse); // [ 8, 6, 3, 1 ] [ 1, 3, 6, 8 ]
```

### [`slice(start?, end?)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)

- **Effet** : Immuable
- **But** : Extrait une copie (superficielle) d'une portion `[start, end)`
- **Retour** : Un **nouveau tableau** contenant les √©l√©ments extraits.

```javascript
console.log(tSlice.slice(1, 3));  // ["B", "C"]
console.log(tSlice.slice(2));     // ["C", "D"]
console.log(tSlice.slice(-2));    // ["C", "D"]
console.log(tSlice.slice(4));     // []
const copieSlice = tSlice.slice(); // copie superficielle
console.log(tSlice, copieSlice.reverse()); // [ 'A', 'B', 'C', 'D' ] [ 'D', 'C', 'B', 'A' ] // original pas affect√©! 
```

### [`splice(start, deleteCount?, ...itemsToAdd)`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)

- **Effet** : Muable
- **But** : **Enlever** et/ou **ins√©rer** des √©l√©ments au milieu
- **Retour** : Un tableau contenant les √©l√©ments supprim√©s. Si un seul √©l√©ment est supprim√©, un tableau contenant cet unique √©l√©ment est retourn√©. Si aucun √©l√©ment n'est supprim√©, un tableau vide est retourn√©.

```javascript
const tSplice = ["A", "B", "C", "D"];
// Suppression
const suppr = tSplice.splice(1, 2);
console.log(tSplice, suppr); // [ 'A', 'D' ] [ 'B', 'C' ]
// Insertion
const suppr2 = tSplice.splice(1, 0, "X", "Y");
console.log(tSplice, suppr2); // [ 'A', 'X', 'Y', 'D' ] []
// Remplacement
const suppr3 = tSplice.splice(1, 2, "Q");
console.log(tSplice, suppr3); // [ 'A', 'Q', 'D' ] [ 'X', 'Y' ]
```

### [`toString()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array/toString)

- **Effet** : Immuable
- **But** : Avoir une repr√©sentation du tableau en `string`
- **Retour** : Renvoie une cha√Æne des √©l√©ments s√©par√©s par des virgules.

```javascript
const tToString = [1, "A", true];
console.log(tToString.toString()); // "1,A,true"
```

## 6. Notes & Bonnes pratiques

- **Mutation vs immutabilit√©** : privil√©giez les m√©thodes **immuables** (`slice`, `at`, `indexOf`, `toString`, `join`) si vous voulez √©viter les effets de bord. Les m√©thodes **mutables** (`push`, `pop`, `shift`, `unshift`, `sort`, `reverse`, `splice`) modifient le tableau d'origine.
- **Copies rapides** : `const copie = [...t]` (spread) ou `t.slice()` (copie superficielle).
- **Tri num√©rique** : toujours fournir un comparateur `sort((a, b) => a - b)`.
- **Indices n√©gatifs** : `at(-1)` (pr√©f√©rable √† `t[t.length - 1]` pour la lisibilit√©).
- **Performance** : `push`/`pop` sont g√©n√©ralement plus performants que `shift`/`unshift` (car ces derniers re-indexent les √©l√©ments).
