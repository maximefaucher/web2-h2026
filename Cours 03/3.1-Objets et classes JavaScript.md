# Les objets et les classes en JavaScript (Node.js)

## 1. Introduction

- **Pourquoi des objets ?**  
Ils permettent de regrouper des **données** (propriétés) et des **comportements** (méthodes) dans une même entité cohérente.

## 2. Les objets en JavaScript

### 2.1. Définition

Un **objet** est un regroupement de **paires clé : valeur**. Les valeurs peuvent être de **n'importe quel type** (nombre, chaîne, booléen, tableau, fonction, autre objet, etc.).

### 2.2. Créer un objet

#### Syntaxe littérale

```js
const etudiant = {
  nom: "Bob",
  note: 85,
  afficher() {
    console.log(`${this.nom} : ${this.note}`);
  }
};
```

#### Fonction constructeur (intermédiaire entre littéral et classe)

```javascript
const Etudiant = function(nom="Inconnu", note=0) {
    this.nom = nom;
    this.note = note;
    this.afficher = function() {
        console.log(`L'étudiant ${this.nom} a obtenu la note de ${this.note}%`);
    };
}

// Instanciation
const etu1 = new Etudiant("Maxime", 89);
```

### 2.3. Accéder aux propriétés / valeurs

- **Notation point** : `etudiant.nom`
- **Notation crochets** (clés dynamiques ou non valides en notation point) : `etudiant["nom complet"]`
- **Boucle `for...in`** qui permet de parcourir les **propriétés énumérables** d'un objet dans un ordre arbitraire
- **Boucle `for...of`** qui permet permet quant à elle de **parcourir les valeurs** contenues dans l'objet itérable visé

[Voir ici](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Statements/for...of#les_diff%C3%A9rences_entre_for...of_et_for...in) pour une explication de la différence entre `for...in` et `for...of`.

### 2.4. Propriétés : clés et valeurs

- Les **clés** sont des chaînes (ou des `Symbol`).
- Les **valeurs** peuvent être de tout type (y compris des fonctions → **méthodes**).

#### Astuces utiles

- **Shorthand** (raccourci) :

    ```js
    const nom = "Bob"; const note = 85;
    const e = { nom, note }; // équivaut à { nom: nom, note: note }
    ```

- **Propriétés calculées** :

    ```js
    const cle = "moyenne";
    const r = { [cle]: 79 };
    ```

- **Déstructuration** (basique) :

  ```js
  const { nom: n, note: x } = etudiant; // n = "Bob", x = 85
  ```

### 2.5. Méthodes d'objets et `this`

- Une **méthode** est une fonction stockée dans une propriété. À l'intérieur, `this` fait référence à **l'objet courant** (selon la façon d'appeler la méthode).
- **Attention** : Les **fonctions fléchées** (`=>`) ne lient pas leur propre `this`. Pour des méthodes normales, préférez la syntaxe classique `afficher() { ... }`.

### 2.6. Méthodes utiles de `Object`

> À utiliser avec parcimonie. Elles sont pratiques pour parcourir/inspecter des objets.

- `Object.keys(obj)` → tableau des **clés**
- `Object.values(obj)` → tableau des **valeurs**
- `Object.entries(obj)` → tableau de **[clé, valeur]**
- `Object.assign(cible, source)` → **copie superficielle** des propriétés
- **Copie avec spread** (équivalent courant) : `{ ...obj }`

## 3. Les classes en JavaScript

Les **classes** (syntaxe introduite avec ES6) offrent un moyen plus lisible de créer des *types d'objets* réutilisables.

### 3.1. Exemples et motivation

- Modéliser un **type** : `Etudiant`, `Produit`, `Livre`, etc.
- Factoriser la création de plusieurs objets semblables.

### 3.2. Syntaxe de base

```js
class Etudiant {
  constructor(matricule, prenom, nom, note) {
    this.matricule = matricule;
    this.prenom = prenom;
    this.nom = nom;
    this.note = Number(note);
  }

  afficher() {
    console.log(`${this.prenom} ${this.nom} (${this.matricule}) → ${this.note}`);
  }

  get nomComplet() {
    return `${this.prenom} ${this.nom}`;
  }
}

const e1 = new Etudiant("20001234", "Marc", "Tremblay", 92);
e1.afficher();
```

### 3.3. Attributs, constructeur, méthodes

- **Attributs** : propriétés portées par chaque instance (`this.attribut`).
- **Constructeur** : fonction spéciale exécutée à `new`.
- **Méthodes** : comportements attachés à la classe/instances.
- **(Optionnel)** Champs privés `#secret` (syntaxe moderne), **getters/setters**, **méthodes statiques** `static`.

### 3.4. Encapsulation (niveau simple)

- Commencez public, puis **introduisez** les champs privés `#` plus tard si besoin.

## 4. Exportation et importation (Node.js)

### 4.1. Pourquoi modulariser?

- Séparer **modèle**, **logique**, **interface**.
- Favoriser la réutilisation et les tests.

### 4.2. Deux systèmes de modules

- **ES modules (ESM)** → `import` / `export` (recommandé). Nécessite Node ≥ 16 et souvent `"type": "module"` dans `package.json`.
- **CommonJS (CJS)** → `require` / `module.exports` (héritage de Node).

### 4.3. Syntaxes courantes (ESM)

#### Exporter (fichier `Etudiant.js`)

```js
export default class Etudiant { /* ... */ }
```

#### Importer

```js
import Etudiant from "./Etudiant.js";
```

#### Exports nommés

```js
// Dans stats.js
export const somme = (a, b) => a + b;
export function moyenne(notes) { /* ... */ }

// Dans main.js
import { somme, moyenne } from "./stats.js";
```

> **Astuce** : si votre environnement n'est pas en ESM, utilisez plutôt CJS :

```js
// CommonJS
class Etudiant { /* ... */ }
module.exports = Etudiant;
// ailleurs
const Etudiant = require('./Etudiant');
```

## 5. Exemple d'application simple (console)

**Idée** : menu en boucle avec `readline` (sans dépendances). Opérations : lister, ajouter, supprimer par matricule, filtrer (seuil de note), trier (nom/note), calculer la moyenne.

Extrait (très résumé) :

```js
import { createInterface } from 'node:readline/promises';
const rl = createInterface({ input: process.stdin, output: process.stdout });

const menu = `\n1) Lister\n2) Ajouter\n3) Supprimer\n4) Filtrer\n5) Trier\n6) Moyenne\n0) Quitter`;

async function boucle() {
  let choix = '';
  do {
    console.log(menu);
    choix = (await rl.question('Choix: ')).trim();
    // switch(choix) { ... }
  } while (choix !== '0');
  rl.close();
}

boucle();
```

## 6. Bonnes pratiques & pièges courants

- **Copie superficielle** vs **copie profonde** : `{ ...obj }` ne clone pas les objets imbriqués profondément.
- **Tri** : `Array.prototype.sort` trie **en place**; fournir un comparateur numérique pour éviter l'ordre lexicographique.
- **JSON** : la sérialisation **perd les méthodes** (on ne stocke que des données). Recréez les instances après lecture si nécessaire.
- **`this`** : attention aux fonctions fléchées dans des méthodes.

## 7. (Référence rapide) Tri et filtrage de tableaux d'objets

```js
// Tri par note décroissante
etudiants.sort((a, b) => b.note - a.note);

// Tri par nom (ordre alphabétique, insensible à la casse)
etudiants.sort((a, b) => a.nom.localeCompare(b.nom, 'fr', { sensitivity: 'base' }));

// Filtrer: notes >= 60
const reussites = etudiants.filter(e => e.note >= 60);
```
