# Le format JSON et la gestion de fichiers avec Node.js

> **Objectifs** :

1. Convertir des objets JavaScript au format JSON et les **écrire sur le disque**.
2. **Lire** un fichier JSON pour **restaurer et manipuler** des données dans une application Node.js.

> **Conventions** :

- On utilise les **modules ES** (`import`/`export`/`class`).
- On utilise l'API **`node:fs/promises`** pour les accès aux fichiers.
- On utilise le module **`node:readline/promises`** pour les saisies.

## 1. Le format JSON et les fichiers

**JSON (JavaScript Object Notation)** est un format **texte** pour échanger des données.

- Les fichiers portent l'extension `.json`
- L'encodage est **UTF‑8**
- Types supportés : `object`, `array`, `string`, `number`, `boolean`, `null`
- On ne retrouve **pas de commentaires** (`//` ou `/*...*/`) dans un fichier `.json`
- Les clés des objets sont des chaînes **entre guillemets** doubles
- Les valeurs sont représentées différemment selon leur type

**Exemple** — `data/samples.json` :

```javascript
// Supposons l'objet suivant
const unObj = {
    prenom: "Cole",
    nom: "Caufield",
    age: 25,
    numero: 13,
    stats: {
        buts: 32,
        passes: 25
    },
    equipe: "MTL",
    rangRepechage: [1, 15, 2019] // ronde, rang, année
};
// et le tableau suivant
const tabElements = [
  {
    numero: 1,
    symbole: "H",
    nom: "Hydrogène",
    masseAtomique: 1.008,
    categorie: "non-métal"
  },
  {
    numero: 2,
    symbole: "He",
    nom: "Hélium",
    masseAtomique: 4.0026,
    categorie: "gaz noble"
  },
  {
    numero: 6,
    symbole: "C",
    nom: "Carbone",
    masseAtomique: 12.011,
    categorie: "non-métal"
  },
  {
    numero: 8,
    symbole: "O",
    nom: "Oxygène",
    masseAtomique: 15.999,
    categorie: "non-métal"
  },
  {
    numero: 11,
    symbole: "Na",
    nom: "Sodium",
    masseAtomique: 22.99,
    categorie: "métal alcalin"
  },
  {
    numero: 26,
    symbole: "Fe",
    nom: "Fer",
    masseAtomique: 55.845,
    categorie: "métal de transition"
  }
];
```

alors leur représentations en chaînes JSON brutes (*raw*) seront respectivement

```json
{"prenom":"Cole","nom":"Caufield","age":25,"numero":13,"stats":{"buts":32,"passes":25},"equipe":"MTL","rangRepechage":[1,15,2019]}
```

et

```json
[{"numero":1,"symbole":"H","nom":"Hydrogène","masseAtomique":1.008,"categorie":"non-métal"},{"numero":2,"symbole":"He","nom":"Hélium","masseAtomique":4.0026,"categorie":"gaz noble"},{"numero":6,"symbole":"C","nom":"Carbone","masseAtomique":12.011,"categorie":"non-métal"},{"numero":8,"symbole":"O","nom":"Oxygène","masseAtomique":15.999,"categorie":"non-métal"},{"numero":11,"symbole":"Na","nom":"Sodium","masseAtomique":22.99,"categorie":"métal alcalin"},{"numero":26,"symbole":"Fe","nom":"Fer","masseAtomique":55.845,"categorie":"métal de transition"}]
```

## 2. L'objet global `JSON` et ses principales méthodes

L'objet `JSON` est principalement utilisé via les 2 méthodes statiques suivantes :

|Méthode|Utilisation|Retour|
|---|---|---|
|[`JSON.stringify(valeur[, remplaçant [, espace]])`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)|Convertir une `valeur` JS en chaîne au format JSON|`String`|
||`remplaçant` (optionnel) : fonction ou tableau||
||`espace` (optionnel) : nombre ou chaîne||
|[`JSON.parse(texte[, reviver])`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)|Analyse une chaîne de caractères JSON et construit la donnée JS ou l'objet décrit par cette chaîne|`Object`|
||`reviver` (optionnel) : fonction||

### `JSON.stringify(value, remplaçant?, espace?)`

- Sérialise une valeur JS en chaîne JSON
- `remplaçant` (facultatif) : fonction ou tableau de clés pour filtrer/modifier les propriétés à inclure dans la chaîne
- `espace` (facultatif) : nombre d'espaces d'indentation (ex. 2) ou chaîne qui agira comme séparateur.

> **Bonne pratique** :  
Formater avec une indentation de **2 espaces** (pour l'économie de stockage) ou **4 espaces** (pour la lisibilité). Éviter les tabulations.

---

> **Remarque** :  
Si vous voulez spécifier un nombre d'espaces pour l'indentation mais **sans spécifier de `remplaçant`**, passez `null` comme 2e argument dans l'appel à la méthode.  
*Ex.* : `const str = JSON.stringify(unObjet, null, 2);`

```js
const obj = { id: 1, name: "Specimen", tmp: undefined, createdAt: null };

// Par défaut
const s1 = JSON.stringify(obj);
console.log(s1); // {"id":1,"name":"Specimen","createdAt":null}

// Avec indentation et filtrage de clés
const s2 = JSON.stringify(obj, ["id", "name", "tmp"], 4);
console.log(s2);
/*
{
    "id": 1,
    "name": "Specimen"
}
*/

// Remplaçant pour transformer (ex: nom en majuscules)
const remplacer = (cle, valeur) => {
    if(cle === 'name') return valeur.toUpperCase();
    return valeur;
}
const s3 = JSON.stringify(obj, remplacer, 2);
console.log(s3);
/*
{
  "id": 1,
  "name": "SPECIMEN",
  "createdAt": null
}
*/
```

> **Attention** :  
> `undefined`, fonctions et symboles ne sont **pas** sérialisés (omission);  
> les références circulaires provoquent une `Error`.

### `JSON.parse(text, reviver?)`

- Convertit une chaîne JSON en valeur JS
- `reviver` (facultatif) : fonction `(key, value)` pour transformer à la volée

```js
// Restituons nos chaînes converties précédemment
const coleCaufield = JSON.parse(chaineObj);
console.log(coleCaufield);
/*
{
  prenom: 'Cole',
  nom: 'Caufield',
  age: 25,
  numero: 13,
  stats: { buts: 32, passes: 25 },
  equipe: 'MTL',
  rangRepechage: [ 1, 15, 2019 ]
}
*/

// Définissons un 'reviver'
const reviver = (cle, valeur) => {
    if(cle === 'categorie') {
        // on met la première lettre en majuscule, le reste tel quel
        valeur = valeur[0].toUpperCase() + valeur.substring(1);
    }
    return valeur;
};
const elements = JSON.parse(chaineTab, reviver);
console.log(elements);
/*
[
  {
    numero: 1,
    symbole: 'H',
    nom: 'Hydrogène',
    masseAtomique: 1.008,
    categorie: 'Non-métal'
  },
  {
    numero: 2,
    symbole: 'He',
    nom: 'Hélium',
    masseAtomique: 4.0026,
    categorie: 'Gaz noble'
  },
  {
    numero: 6,
    symbole: 'C',
    nom: 'Carbone',
    masseAtomique: 12.011,
    categorie: 'Non-métal'
  },
  {
    numero: 8,
    symbole: 'O',
    nom: 'Oxygène',
    masseAtomique: 15.999,
    categorie: 'Non-métal'
  },
  {
    numero: 11,
    symbole: 'Na',
    nom: 'Sodium',
    masseAtomique: 22.99,
    categorie: 'Métal alcalin'
  },
  {
    numero: 26,
    symbole: 'Fe',
    nom: 'Fer',
    masseAtomique: 55.845,
    categorie: 'Métal de transition'
  }
]
*/
```

> **Limites** : pas de support natif pour `BigInt` ; les nombres très grands peuvent perdre en précision.

## 3. Écrire des données au format JSON sur le disque (Node.js)

Supponsons que l'on souhaite sauvegarder notre objet (joueur de hockey) et notre tableau d'éléments. Voyons comment il est possible d'y arriver avec Node.js.

### Modules requis

Nous allons utiliser les modules natifs suivants :

1. Le module asynchrone `node:fs/promises` pour l'écriture en tant que telle
2. Le module `node:path` pour résoudre les chemins d'accès aux fichiers

```javascript
// Importations
import fs from 'node:fs/promises';
import path from 'node:path';
```

### Méthode [`path.resolve()`](https://nodejs.org/api/path.html#pathresolvepaths)

Cette méthode **construit un chemin absolu normalisé** à partir d'un ou plusieurs portions de chemin.

Concrètement :

- elle **concatène** des chemins
- elle résout `.` et `..`
- elle retourne **toujours un chemin absolu**

```javascript
const cheminIci = path.resolve('.');
// équivalent à 
const cheminIci2 = path.resolve();
// et à
const cheminIci3 = process.cwd(); // cwd = current working directory
console.log(cheminIci);
console.log(cheminIci2);
console.log(cheminIci3);

const chemin2NivSup = path.resolve('./../../');
// const chemin2NivSup = path.resolve('.', '..', '..'); // équivalent
console.log(chemin2NivSup);

const dossierSortie = path.resolve('./sortie');
console.log(dossierSortie);

// Vérifier l'existence d'un dossier
try {
    await fs.access(dossierSortie);
}
catch(err) {
    console.log(err);
    if(err.code === 'ENOENT') {
        // On crée les dossiers requis
        fs.mkdir(dossierSortie, {recursive: true});
    }
}
```

### Méthodes d'écriture du module `node:fs/promises`

Ce module est **asynchrone** et toutes les méthodes ci-dessous

- retournent une `Promise`
- s'utilisent naturellement avec `async` / `await`

|Méthode (syntaxe)|Ce qu'elle fait|Exemple d'appel|Cas d'usage|
|---|---|---|---|
|[`.writeFile(file, data[, options])`](https://nodejs.org/api/fs.html#fspromisesappendfilepath-data-options)|**La plus utilisée**|`await fs.writeFile("data.txt", "Texte", {encoding: "utf8", flag: "w"});`|Écriture unique|
||Crée le fichier s'il n'existe pas||Sauvegarder une config, un JSON, un rapport|
||Écrase le contenu s'il existe (par défaut)|||
|[`.appendFile(path, data[, options])`](https://nodejs.org/api/fs.html#fspromisesappendfilepath-data-options)|**Ajouter à la fin d'un fichier**|`await fs.appendFile("log.txt", "Nouvelle ligne\n");`|Fichiers de logs|
||Crée le fichier s'il n'existe pas||Historique de commandes|
||Ajoute à la fin (*append*)|||

```javascript

// Écrivons!
try {
    const fichier1 = path.resolve(dossierSortie, 'joueur.json')
    await fs.writeFile(fichier1, chaineObj);
    console.log(`Écriture de ${fichier1} réussie!`);
}
catch(err) {
    console.log(err);
}

try {
    const fichier2 = path.resolve(dossierSortie, 'elements.json');
    await fs.writeFile(fichier2, chaineTab);
    console.log(`Écriture de ${fichier2} réussie!`);
}
catch(err) {
    console.log(err);
}
```

## 4. Lecture de fichiers au format JSON sur le disque (Node.js)

On utilise les 2 mêmes modules que pour l'écriture.

### Méthode de lecture du module `node:fs/promises`

|Méthode (syntaxe)|Ce qu'elle fait|Exemple d'appel|Cas d'usage|
|---|---|---|---|
|[`.readFile(path[, options])`](https://nodejs.org/api/fs.html#fspromisesreadfilepath-options)|**La plus utilisée**|`const contenu = await fs.readFile("data.txt", "utf8");`|Fichiers texte|
||Lit **tout le fichier** en mémoire||JSON|
||Retourne une `String` (si encodage fourni)||Fichiers de taille raisonnable|
||Retourne un `Buffer` (sinon ⚠️)|||

```javascript
import Element from "./modele/Element.js"; // classe pour nos objets
import path from 'node:path';
import fs from 'node:fs/promises';

const fichierElements = path.resolve('.', 'sortie', 'elements.json');
let _elements = []; // pour stocker les objets

try {
    const raw = await fs.readFile(fichierElements, 'utf-8');
    const arr = JSON.parse(raw);
    _elements = arr.map(e => new Element(e.numero, e.symbole, e.nom, e.masseAtomique, e.categorie));
} catch (err) {
    if (err.code === 'ENOENT') { // si le fichier est inexistant
        _elements = [];
    }
    throw err; // is autre erreur, on la relance
}

_elements.forEach(element => { console.log(element.ligneInfos); });
/*
1 - [H] Hydrogène, masse atomique = 1.008 : non-métal
2 - [He] Hélium, masse atomique = 4.0026 : gaz noble
6 - [C] Carbone, masse atomique = 12.011 : non-métal
8 - [O] Oxygène, masse atomique = 15.999 : non-métal
11 - [Na] Sodium, masse atomique = 22.99 : métal alcalin
26 - [Fe] Fer, masse atomique = 55.845 : métal de transition
*/
```

#### Le code de la classe `Element`

```javascript
export default class Element {
    constructor(numero, symbole, nom, masseAtomique, categorie) {
        this.numero = numero;
        this.symbole = symbole;
        this.nom = nom;
        this.masseAtomique = masseAtomique;
        this.categorie = categorie;
    }

    get ligneInfos() {
        return `${this.numero} - [${this.symbole}] ${this.nom}, masse atomique = ${this.masseAtomique} : ${this.categorie}`
    }
}
```
