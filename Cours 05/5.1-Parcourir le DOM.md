# Parcourir les éléments du DOM

> **Objectif** : Savoir naviguer verticalement (parent/enfants) et horizontalement (fratrie) dans l'arborescence du DOM en JavaScript, avec des exemples clairs et de bonnes pratiques.

## 1. Préambule rapide

- Toutes les propriétés ci-dessous renvoient **des noeuds de type élément** (`HTMLElement`), pas les noeuds texte.
- Elles sont **en lecture seule** : vous lisez la structure, mais vous ne la modifiez pas.
- Pensez à toujours vérifier l'**existence** d'un élément avant de l'utiliser (peut être `null`).

Exemple de base HTML que nous utiliserons dans plusieurs extraits :

```html
<ul id="menu">
  <li class="item">Accueil</li>
  <li class="item actif">Produits</li>
  <li class="item">Contact</li>
</ul>
```

## 2. Parcours vertical

### `.firstElementChild`

Renvoie le **premier enfant élément** d'un élément parent. Retourne `null` si aucun enfant élément n'existe.

```js
const menu = document.getElementById('menu');
const premier = menu.firstElementChild; // <li class="item">Accueil</li>
if (premier) {
  console.log(premier.textContent.trim()); // "Accueil"
}
```

**À retenir** :

- Ignore les noeuds texte (espaces, retours lignes).
- Équivalent moderne à préférer plutôt que `firstChild` (qui peut renvoyer un noeud texte).

### `.lastElementChild`

Renvoie le **dernier enfant élément** d'un élément parent. Retourne `null` si aucun enfant élément n'existe.

```js
const dernier = menu.lastElementChild; // <li class="item">Contact</li>
if (dernier) {
  dernier.classList.add('dernier');
}
```

**Astuce** :

- Utile pour cibler rapidement la fin d'une liste ou d'un conteneur sans calculer la longueur.

### `.children`

Renvoie une **HTMLCollection vivante** de **tous les enfants éléments** (pas un tableau).

```js
const enfants = menu.children; // HTMLCollection(3)
// Itération :
for (const li of enfants) {
  li.classList.add('menu-item');
}

// Convertir en tableau si besoin de méthodes d'Array :
const arr = Array.from(enfants);
const textes = arr.map(li => li.textContent.trim());
console.log(textes); // ["Accueil", "Produits", "Contact"]
```

**À retenir** :

- Collection **vivante** : se met à jour si le DOM change.
- Si vous avez besoin d'une copie, utilisez `Array.from()` ou l'opérateur spread `[...]`.

### `.parentElement`

Renvoie l'**élément parent** d'un noeud courant (ou `null` s'il n'existe pas ou si le parent n'est pas un élément).

```js
const produit = document.querySelector('#menu .actif');
const parent = produit.parentElement; // <ul id="menu">...</ul>
if (parent && parent.id === 'menu') {
  parent.classList.add('avec-actif');
}
```

**Différence** :

- `parentNode` peut renvoyer **tout type de noeud** (y compris `Document`), alors que `parentElement` garantit un **HTMLElement** ou `null`.

### `.closest(selector)`

Renvoie l'**ancêtre le plus proche** (y compris lui-même) qui correspond au sélecteur CSS fourni. Retourne `null` si aucun ancêtre ne correspond.

```js
const item = document.querySelector('.actif');
const ul = item.closest('ul'); // <ul id="menu">...</ul>
if (ul) {
  ul.classList.add('avec-actif');
}
```

**Cas d'usage** :

- Trouver rapidement un conteneur parent spécifique sans parcourir manuellement.
- Utile pour la délégation d'événements (ex. trouver le parent qui gère l'événement).

## 3. Parcours horizontal

### `.nextElementSibling`

Renvoie l'**élément suivant** au même niveau (frère immédiatement après). Retourne `null` si aucun suivant.

```js
const actif = document.querySelector('#menu .actif');
const suivant = actif.nextElementSibling; // <li class="item">Contact</li>
if (suivant) {
  suivant.style.fontWeight = 'bold';
}
```

**Cas d'usage** :

- Naviguer pas à pas dans une liste.
- Construire des parcours clavier (flèche droite → élément suivant).

### `.previousElementSibling`

Renvoie l'**élément précédent** au même niveau (frère immédiatement avant). Retourne `null` si aucun précédent.

```js
const precedent = actif.previousElementSibling; // <li class="item">Accueil</li>
if (precedent) {
  precedent.setAttribute('aria-current', 'false');
}
```

## 4. Bonnes pratiques générales

- **Toujours tester le `null`** pour éviter les erreurs aux extrémités (début/fin de liste).
- Combinez ces propriétés pour des parcours plus riches :

```js
// Aller du premier item au suivant, puis remonter au parent
const first = menu.firstElementChild;
if (first) {
  const next = first.nextElementSibling;
  if (next) {
    const parent = next.parentElement; // revient à <ul id="menu">
  }
}
```

## 5. Comparaisons utiles

- `firstElementChild` / `lastElementChild` vs `firstChild` / `lastChild` :
  - *Element* → garantit un **élément** ;
  - *Child* générique → peut être **texte/commentaire**.
- `children` vs `childNodes` :
  - `children` → **HTMLCollection** d'éléments uniquement ;
  - `childNodes` → **NodeList** de *tous* les noeuds (texte, commentaires, etc.).
- `nextElementSibling` / `previousElementSibling` vs `nextSibling` / `previousSibling` : même logique (éléments vs noeuds génériques).

## 6. Récapitulatif

- **Vertical** : `firstElementChild`, `lastElementChild`, `children`, `parentElement`.
- **Horizontal** : `nextElementSibling`, `previousElementSibling`.
- Préférez les versions *Element* pour éviter les noeuds texte.
- Vérifiez toujours `null` et convertissez `children` en tableau si nécessaire.
