# La gestion des événements du DOM

## 1. Qu'est‑ce qu'un événement du DOM ?

Un **événement du DOM** (Document Object Model) **est une action ou un changement** détecté par le navigateur sur une page Web.

Exemples :

- Un clic
- Une touche de clavier
- Le chargement de la page
- La souris qui bouge
- Etc.

Le navigateur "prévient" JavaScript qu'un événement s'est produit, et on peut alors réagir en conséquence.

## 2. Les principaux types d'événements

Voici un tableau regroupant les **principaux événements du DOM**, classés par catégorie.

|Catégorie|Événement(s)|Description|
|---|---|---|
|**Chargement / Page**|`load`|Se déclenche quand toute la page est chargée.|
||`DOMContentLoaded`|Se déclenche quand le HTML est chargé (avant les images).|
||`beforeunload`|Se déclenche juste avant que l'utilisateur quitte la page.|
||`unload`|La page est déchargée (fermeture ou navigation).|
|**Souris**|`click`|Clic simple.|
||`dblclick`|Double‑clic.|
||`mousemove`|La souris bouge.|
||`mousedown` / `mouseup`|Bouton de souris pressé / relâché.|
||`mouseenter` / `mouseleave`|La souris entre / sort d'un élément.|
||`contextmenu`|Clic droit (ou ouverture du menu contextuel).|
|**Clavier**|`keydown`|Une touche est enfoncée.|
||`keyup`|Une touche est relâchée.|
||`keypress`|(Déprécié) Quand une touche produit un caractère.|
|**Formulaires**|`submit`|Un formulaire est envoyé.|
||`change`|Valeur modifiée (après validation).|
||`input`|Une valeur change en temps réel (champ texte).|
||`focus` / `blur`|Un élément reçoit / perd le focus.|
|**Fenêtre / Affichage**|`resize`|La fenêtre change de taille.|
||`scroll`|L'utilisateur fait défiler la page.|
|**Clavier tactile / Mobile**|`touchstart`|Un doigt touche l'écran.|
||`touchmove`|Le doigt glisse sur l'écran.|
||`touchend`|Le doigt se lève de l'écran.|
|**Éléments multimédia**|`play`|Une vidéo/son démarre.|
||`pause`|Mise en pause.|
||`ended`|Lecture terminée.|

## 3. Comment réagir à un événement du DOM?

Pour réagir à un événement du DOM, on utilise la méthode [`addEventListener()`](https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener).

> **Syntaxe** :  
`element.addEventListener('type', callback, options?, );`

- `type` : Le type d'événement (ex. `'click'`, `'keydown'`, etc.).
- `callback` : La fonction à exécuter lorsque l'événement se produit.
  - Cette fonction reçoit un objet `event` en paramètre, qui contient des informations sur l'événement.
  - Il est possible d'utiliser une fonction anonyme ou une fonction nommée.
  - On récupère l'élément qui a déclenché l'événement via `event.target`.
- `options` : Un objet optionnel pour configurer l'écouteur (ex. `{ once: true }` pour n'écouter qu'une fois).

### Exemples typiques d'écouteurs d'événements

Voici quelques exemples classiques d'utilisation de `addEventListener`, avec des variations sur les types de fonctions utilisées (anonyme vs nommée, fléchée vs mot-clé `function`). Les fonctions anonymes sont définies directement dans l'appel, tandis que les nommées sont définies séparément. Les fonctions fléchées (`=>`) sont plus concises et n'ont pas leur propre `this`, contrairement aux fonctions avec `function` qui l'ont.

1. **Clic sur un bouton** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    const bouton = document.querySelector('#monBouton');
    bouton.addEventListener('click', function(event) {
        console.log('Bouton cliqué! (function anonyme)');
     });
     ```

    *Particularité* : La fonction anonyme est définie sur place ; `this` fait référence à l'élément qui a déclenché l'événement.

    - Avec fonction nommée et fléchée :

    ```javascript
    const bouton = document.querySelector('#monBouton');
    const gererClic = (event) => console.log('Bouton cliqué! (fonction fléchée nommée)');
    bouton.addEventListener('click', gererClic);
    ```

    *Particularité* : La fonction fléchée est concise et `this` hérite du contexte parent (pas l'élément).

2. **Soumission d'un formulaire** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    const formulaire = document.querySelector('#monFormulaire');
    formulaire.addEventListener('submit', function(event) {
        event.preventDefault();
        console.log('Formulaire soumis (function anonyme)');
    });
    ```

    *Particularité* : Utile pour des actions simples ; `this` est l'élément formulaire.

    - Avec fonction nommée et fléchée :

    ```javascript
    const formulaire = document.querySelector('#monFormulaire');
    const soumettreForm = (event) => {
        event.preventDefault();
        console.log('Formulaire soumis (fonction fléchée anomyme)');
    };
    formulaire.addEventListener('submit', soumettreForm);
    ```

    *Particularité* : La fonction fléchée permet une syntaxe plus courte ; `this` n'est pas lié à l'élément.

3. **Changement de valeur dans un champ input** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    const input = document.querySelector('#monInput');
    input.addEventListener('input', function(event) {
        console.log('Valeur changée : ', event.target.value);
    });
    ```

    *Particularité* : Idéal pour des événements fréquents ; `this` est l'input.

    - Avec fonction nommée et fléchée :

    ```javascript
    const input = document.querySelector('#monInput');
    const changerValeur = (event) => console.log('Valeur changée :', event.target.value);
    input.addEventListener('input', changerValeur);
    ```

    *Particularité* : Syntaxe compacte ; évite les problèmes de `this` dans les boucles.

4. **Appui sur une touche** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Enter') {
            console.log('Entrée pressée');
        }
    });
    ```

     *Particularité* : Attaché au document pour les événements globaux ; `this` est le document.

    - Avec fonction nommée et fléchée :

    ```javascript
    const gererTouche = (event) => {
        if (event.key === 'Enter') {
            console.log('Entrée pressée');
        }
    };
    document.addEventListener('keydown', gererTouche);
    ```

    *Particularité* : Fonction réutilisable ; `this` hérite du contexte extérieur.

5. **Survol d'un élément** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    const element = document.querySelector('#monElement');
    element.addEventListener('mouseenter', function(event) {
        event.target.style.backgroundColor = 'yellow';
    });
    element.addEventListener('mouseleave', function(event) {
        event.target.style.backgroundColor = '';
    });
    ```

    *Particularité* : Deux écouteurs séparés ; `this` est l'élément survolé.

    - Avec fonction nommée et fléchée :

    ```javascript
    const element = document.querySelector('#monElement');
    const entrer = (event) => event.target.style.backgroundColor = 'yellow';
    const sortir = (event) => event.target.style.backgroundColor = '';
    element.addEventListener('mouseenter', entrer);
    element.addEventListener('mouseleave', sortir);
    ```

    *Particularité* : Fonctions nommées pour une meilleure lisibilité ; pas de `this` propre.

6. **Chargement de la page** :
    - Avec fonction anonyme et mot-clé `function` :

    ```javascript
    window.addEventListener('load', function(event) {
        console.log('Page chargée');
    });
    ```

    *Particularité* : Exécuté une fois ; `this` est la fenêtre.

    - Avec fonction nommée et fléchée :

    ```javascript
    const pageChargee = (event) => console.log('Page chargée');
    window.addEventListener('load', pageChargee);
    ```

    *Particularité* : Concis et réutilisable ; `this` hérite du contexte global.

## 4. Retirer un écouteur d'événements

Pour retirer un écouteur d'événements ajouté avec `addEventListener`, on utilise la méthode `removeEventListener()`. Elle prend les mêmes paramètres : le type d'événement et la référence exacte à la fonction callback.

- *Avec un callback nommé* : **Facile à retirer**, car on a une référence à la fonction.

  ```javascript
  const gererClic = (event) => console.log('Clic géré');
  bouton.addEventListener('click', gererClic);
  // Plus tard...
  bouton.removeEventListener('click', gererClic);
  ```

- *Avec un callback anonyme* : **Impossible de retirer directement**, car on n'a pas de référence. Il est donc préférable (bonne pratique) de nommer les fonctions rattachées à des écouteurs d'événements.

  ```javascript
  const gererClicAnonyme = function(event) { console.log('Clic anonyme'); };
  bouton.addEventListener('click', gererClicAnonyme);
  // Pour retirer :
  bouton.removeEventListener('click', gererClicAnonyme);
  ```

  *Particularité* : Les callbacks anonymes sont pratiques pour des usages temporaires, mais pour une gestion fine des événements (ajout/suppression dynamique), préférez les callbacks nommés.
