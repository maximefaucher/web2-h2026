# Modifier un `HTMLElement` du DOM

## Table des matières

- [1. La classe `Element` de l'API DOM](#1-la-classe-element-de-lapi-dom)
- [2. La classe `HTMLElement`](#2-la-classe-htmlelement)
- [3. Propriétés et attributs](#3-propriétés-et-attributs)
- [4. Lecture d'une propriété ou d'un attribut](#4-lecture-dune-propriété-ou-dun-attribut)
- [5. Modification d'une propriété ou d'un attribut](#5-modification-dune-propriété-ou-dun-attribut)
- [6. Contenu textuel et HTML d'un `HTMLElement`](#6-contenu-textuel-et-html-dun-htmlelement)
  - [`.textContent`](#textcontent)
  - [`.innerHTML`](#innerhtml)
  - [`.outerHTML`](#outerhtml)
  - [`.innerText` (prend en compte le rendu CSS)](#innertext-prend-en-compte-le-rendu-css)

## 1. La classe `Element` de l'API DOM

Dans l'API DOM, la classe `Element` représente un élément HTML ou XML. C'est une interface de base pour tous les éléments du DOM, et elle hérite de la classe `Node`. Les éléments HTML spécifiques (comme `HTMLElement`, `HTMLDivElement`, etc.) héritent de `Element` et ajoutent des propriétés et méthodes spécifiques à leur type.

## 2. La classe `HTMLElement`

`HTMLElement` est une sous-classe de `Element` qui représente les éléments HTML spécifiques. Elle ajoute des propriétés et méthodes supplémentaires pour manipuler les éléments HTML, comme `innerHTML`, `textContent`, `classList`, etc.

On manipule souvent des instances de `HTMLElement` après les avoir sélectionnées dans le DOM, et c'est à travers ces instances que nous allons accéder ou modifier le contenu et les propriétés des éléments HTML.

### Façons courantes d'obtenir un `HTMLElement`

- `document.getElementById(id)` : retourne un élément avec l'`id` spécifié
- `document.getElementsByClassName(names)` : retourne une collection d'éléments avec la classe spécifiée
- `document.getElementsByTagName(name)` : retourne une collection d'éléments avec le nom de balise spécifié
- `document.querySelector(selectors)` : retourne le premier élément correspondant au sélecteur CSS
- `document.querySelectorAll(selectors)` : retourne une NodeList de tous les éléments correspondant au sélecteur CSS
- `element.children` : retourne une HTMLCollection des éléments enfants directs

On pourra ainsi stocker les appels à ces méthodes dans des variables pour manipuler les éléments du DOM plus facilement.

## 3. Propriétés et attributs

Un élément HTML possède des attributs (dans le code HTML) et des propriétés (dans l'objet JavaScript correspondant). Ces deux notions sont liées, mais **ce n'est pas la même chose**.

### Attribut = ce qui est écrit dans le HTML

Un attribut est une **chaîne de caractères** présente dans le **code HTML initial**.

- Les **attributs**...
  - Ne sont pas typés, tout est texte.
  - La méthode `hasAttribute("attribut")` permet de vérifier la présence d'un attribut.
  - La méthode `removeAttribute("attribut")` permet de supprimer un attribut.
  - La méthode `getAttribute("value")` renvoie la valeur écrite dans le HTML (même si elle ne correspond plus à l'état courant).
  - La méthode `setAttribute("attribut", valeur)` permet de définir ou modifier un attribut.

### Propriété = ce qui vit dans l'objet JavaScript

Un `HTMLElement` est un objet JS avec des propriétés qui reflètent **l'état courant** de l'élément.

- Les **propriétés**...
  - Peuvent être de n'importe quel type (string, boolean, number, etc.).
  - Sont synchronisées avec les attributs correspondants (mais pas toujours de manière bidirectionnelle).
  - Sont accessibles via `element.propriété` et modifiables via `element.propriété = valeur`.

### Relation entre attributs et propriétés

Certains attributs HTML ont une **propriété JS** équivalente (souvent sur `HTMLElement`).

Par exemple :

- Identité & classes : `id`, `className`, `classList`
- Formulaires : `value`, `checked`, `disabled`, `required`
- Liens & médias : `href`, `src`, `alt`
- Accessibilité : `aria*` (via attributs)

Celles-ci sont dites "**réfléchies**" (*reflected*) car elles sont **synchronisées** entre l'attribut HTML et la propriété JS, bien que le comportement exact puisse varier selon l'attribut/propriété.

D'autres attributs, notamment les `data-*` et les attributs personnalisés ne sont **pas synchronisés** par des propriétés JS, et dans ce cas, il faut utiliser les méthodes `getAttribute` et `setAttribute` pour y accéder ou les modifier.

## 4. Lecture d'une propriété ou d'un attribut

Pour **lire la valeur** d'une propriété ou d'un attribut d'un élément, on peut utiliser la syntaxe `element.propriété` ou `element.getAttribute("attribut")`.

```html
<input id="user" type="text" value="Albert" disabled title="Nom d'utilisateur">
```

```js
const element = document.getElementById("user");
const id = element.id; // accès à la propriété id, qui est "user"
const title = element.getAttribute("title"); // accès à l'attribut title, qui est "Nom d'utilisateur"
```

## 5. Modification des propriétés de style et de contenu des éléments HTML avec JavaScript

> **Objectif** : savoir modifier l'apparence (classes CSS et styles inline) et le contenu (texte/HTML) d'éléments du DOM en JavaScript, en comprenant **les différences**, **bonnes pratiques** et **cas d'usage**.

Pour **modifier la valeur** d'une propriété ou d'un attribut, on peut utiliser la syntaxe `element.propriété = valeur` ou `element.setAttribute("attribut", valeur)`.

```html
<div id="msg" class="box info">Bonjour <strong>tout le monde</strong> !</div>
```

```js
const el = document.getElementById('msg');
```

### 5.1 Propriétés de style

#### `.className`

- **Description** : chaîne contenant **toutes** les classes de l'élément (ex. "box info").
- **Lecture/Écriture** : écrire **remplace** l'ensemble des classes.
- **Quand l'utiliser ?** Pour affecter rapidement un jeu de classes complet.

```js
// Lire
console.log(el.className); // "box info"

// Remplacer toutes les classes
el.className = 'box warning';

// Ajouter en concaténant (peu recommandé, risqué sur les espaces/doublons)
el.className += ' rounded';
```

**Pièges** :

- Écraser involontairement d'autres classes.
- Gestion manuelle des espaces/doublons.

#### `.classList` et ses méthodes

- **Description** : interface pratique pour gérer les classes **une par une**.
- **Méthodes clés** :
  - `add('c1', 'c2')`
  - `remove('c1', 'c2')`
  - `toggle('c')` (inverse la présence)
  - `toggle('c', condition)` (force ajout/suppression)
  - `contains('c')` (booléen)
  - `replace('old', 'new')`

```js
el.classList.add('rounded', 'shadow');
el.classList.remove('info');
el.classList.toggle('hidden');           // bascule
el.classList.toggle('is-active', true);  // force l'ajout

if (!el.classList.contains('warning')) {
  el.classList.add('warning');
}

el.classList.replace('warning', 'danger');
```

**Bonnes pratiques** : privilégier `classList` pour éviter d'écraser d'autres classes et pour une intention plus claire.

#### `.style` (objet) et ses propriétés

- **Description** : représente les **styles inline** (attribut `style`), exposés en camelCase (`backgroundColor`, `fontSize`, etc.).
- **Lecture/Écriture** : écrire modifie l'attribut inline **uniquement** (ne touche pas les règles CSS).
- **Quand l'utiliser ?** Pour des ajustements ponctuels, dynamiques ou calculés.

```js
// Affectations unitaires (camelCase)
el.style.backgroundColor = '#fffbcc';
el.style.border = '1px solid #f0ad4e';
el.style.fontSize = '1.1rem';

// Réinitialiser une propriété inline
el.style.backgroundColor = '';

// Définir plusieurs propriétés d'un coup
Object.assign(el.style, {
  padding: '12px',
  color: '#333',
});

// Définir tout le style via cssText (écrase l'existant inline)
el.style.cssText = 'background:#fff3cd;color:#664d03;padding:12px;';
```

**Important** : `el.style` **ne lit pas** les valeurs calculées par les feuilles CSS. Pour cela, utiliser :

```js
const styles = getComputedStyle(el);
console.log(styles.backgroundColor); // valeur calculée (ex: "rgb(255, 243, 205)")
```

**Bonnes pratiques** :

- Préférer ajouter/retirer des **classes** pour les styles liés à la présentation (séparation contenu/style, réutilisabilité, performances).
- Réserver `.style` aux exceptions dynamiques.

### 5.2 Propriétés de contenu

#### `.textContent`

- **Description** : renvoie/positionne **tout le texte** d'un nœud et de ses descendants, **sans interpréter le HTML**.
- **Sécurité** : sûr contre les injections HTML (le texte est échappé).
- **Effets** : l'écriture **remplace** tout le contenu enfant par du texte brut.

```js
console.log(el.textContent); // "Bonjour tout le monde !"
el.textContent = '<em>Salut</em>'; // affiche littéralement <em>Salut</em>
```

#### `.innerText`

- **Description** : similaire à `textContent` mais reflète le **texte rendu** (respecte CSS `display:none`, `text-transform`, etc.). Déclenche des **reflux/repaint** car il interroge la mise en page.
- **Usage** : utile quand vous voulez le texte tel qu'il **apparaît** à l'écran.

```js
console.log(el.innerText);
el.innerText = 'Texte visible';
```

**Différences clés** :

- `textContent` lit/écrit le texte **logique** du DOM (rapide, sans style).
- `innerText` lit/écrit le texte **rendu** (plus lent, dépendant du style).

#### `.innerHTML`

- **Description** : lit/écrit le **HTML interne** de l'élément (interprété comme balisage).
- **Sécurité** : **dangereux** si la source n'est pas fiable → risque **XSS**.
- **Effets** : l'écriture reconstruit les enfants → **perd** les gestionnaires d'évènements attachés sur les anciens nœuds.

```js
// Lire le HTML interne
echo = el.innerHTML; // "Bonjour <strong>tout le monde</strong> !"

// Remplacer par un nouveau fragment HTML
el.innerHTML = `
  <span class="tag">Note</span>
  <em>Salut</em>, <strong>monde</strong> !
`;

// ⚠️ Exemple sécurisé : échapper tout contenu utilisateur (ici via une fonction maison)
function escapeHtml(s) {
  return s
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');
}
const user = '<img src=x onerror=alert(1)>'; // simulé
el.innerHTML = `<p>${escapeHtml(user)}</p>`; // sécurisé
```

**Alternatives plus sûres** :

- Construire les nœuds via `document.createElement`, `append`, `appendChild`, `textContent`.
- Ou utiliser `Element.insertAdjacentHTML(position, html)` **avec HTML de confiance uniquement**.

---

#### `.outerHTML`

- **Description** : lit/écrit le **HTML de l'élément lui‑même** **et** de ses descendants.
- **Effets** : l'écriture **remplace l'élément** par le markup fourni (l'ancienne référence JS devient obsolète).

```js
console.log(el.outerHTML);

// Remplacer tout l'élément
el.outerHTML = '<div id="msg" class="box success">OK ✅</div>';
// ⚠️ Après, `el` référence encore l'ancien nœud détaché. Il faut le retrouver :
const el2 = document.getElementById('msg');
```

## 6. Bonnes pratiques générales

- **Privilégier les classes** (`classList`) pour les styles; minimiser le style inline.
- **Séparer** structure (HTML), présentation (CSS) et interaction (JS).
- **Éviter `innerHTML`** avec des données non fiables; préférer les APIs DOM (createElement, textContent, etc.).
- **Mesurer** l'impact performance (`innerText` peut forcer un layout ; `innerHTML` reconstruit des nœuds).
- **Nettoyer** les écouteurs d'évènements si vous remplacez des nœuds (ou déléguer les évènements au conteneur).

## 7. En résumé (tableau récapitulatif)

|Propriété|Type|Effet principal|Avantages|Inconvénients / Risques|Cas d'usage conseillé|
|---|---|---|---|---|---|
|`className`|chaînes de classes|Remplace toutes les classes|Simple/rapide pour un preset|Écrase involontairement, gestion espaces|Appliquer un set de classes entier|
|`classList`|DOMTokenList|Ajoute/retire/remplace/toggle|Granulaire, sûr|Néant notable|Gestion fine des classes|
|`style`| CSSStyleDeclaration (inline)|Modifie uniquement le style inline|Ajustements ponctuels|Entretient difficile, surcharge style|Valeurs calculées dynamiques|
|`textContent`|string|Texte brut|Sûr, rapide|Ignore le rendu visuel|Injecter du texte utilisateur|
|`innerText`|string|Texte rendu (dépend du layout)|Correspond au visuel|Plus lent (layout), dépend du CSS|Lire/écrire texte tel qu'affiché|
|`innerHTML`|string (HTML)|Remplace le HTML interne|Expressif, concis|XSS, perd handlers, reconstruit DOM|Templates **de confiance**|
|`outerHTML`|string (HTML)|Remplace l'élément lui-même|Remplacement radical|Référence obsolète, mêmes risques XSS|Migration/remplacement complet|

## 8. Voir aussi

- MDN – `Element.className`
- MDN – `Element.classList`
- MDN – `HTMLElement.style`
- MDN – `Node.textContent`
- MDN – `HTMLElement.innerText`
- MDN – `Element.innerHTML`
- MDN – `Element.outerHTML`
